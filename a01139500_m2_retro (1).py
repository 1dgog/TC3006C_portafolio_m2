# -*- coding: utf-8 -*-
"""a01139500_m2_retro.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/1dgog/TC3006C_portafolio_m2/blob/main/a01139500_m2_retro.ipynb

# Módulo 2 Implementación de una técnica de aprendizaje máquina sin el uso de un framework
"""

# Commented out IPython magic to ensure Python compatibility.
from google.colab import drive
drive.mount("/content/gdrive")
!pwd
#put your own path in google drive
# %cd "/content/gdrive/MyDrive"
!ls

"""Se importan las librerías necesarias. sklearn solo se usa para hacer la división de datos de entrenamiento y prueba."""

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt
import math
from sklearn.metrics import classification_report
import seaborn as sns

"""Se importa el CSV, se da nombre a las columnas, y se """

columns = ["alcohol","malic_acid","ash","alcalinity_of_ash", "magnesium","total_phenols","flavanoids","nonflavanoid_phenols","proanthocyanins","color_intensity","hue","od280","proline"] # definir nombres de columna manualmente
df = pd.read_csv('wine.data',names = columns) # abrir el archivo de datos con los nombres dados para las columnas
df2 = df.reset_index() # se añade un nuevo indice para que el indice previo sea una clasificación que se usara en la siguiente figura.
df2["clase1"] = df2["index"]==1
df2["clase1"] = df2["clase1"].astype(int)
df2["clase2"] = df2["index"]==2
df2["clase2"] = df2["clase2"].astype(int)
df2["clase3"] = df2["index"]==3
df2["clase3"] = df2["clase3"].astype(int)
df2

sns.lmplot(x='flavanoids',
           y='clase1',
           height=8,
           aspect=.8,
           data = df2,
           fit_reg=False, 
           hue='clase1', 
           legend=True)
sns.lmplot(x='flavanoids',
           y='clase2',
           height=8,
           aspect=.8,
           data = df2,
           fit_reg=False, 
           hue='clase2', 
           legend=True)
sns.lmplot(x='flavanoids',
           y='clase3',
           height=8,
           aspect=.8,
           data = df2,
           fit_reg=False, 
           hue='clase3', 
           legend=True)

"""Se selecciona el tipo de clase qe se busca clasificar
---


"""

# poe favor seleccione la columna cambiando el titulo de la columna

funcion_de_clasificacion(df2['clase1'])

"""Se presenta la funcion a la que se le da como input la clase que se busca clasificar."""

def funcion_de_clasificacion(df2_solic):

  # se hace la división entre datos de prueba y datos de 

  x_train, x_test, y_train, y_test = train_test_split(df2["flavanoids"], df2_solic, test_size=0.33, random_state=30)
  
  # se hace una regresión logistica de orden 1

  h   = lambda x,theta: theta[0]+theta[1]*x
  j_i = lambda x,y,theta: (y-h(x,theta))**2 

  alpha = 0.00001

  n = len(y_train)

  theta = [1,1] # Cambiar dependiendo del orden del modelo (un theta para cada dimensión de nuestros datos + 1)

  for idx in range(10000):
    acumDelta = []
    acumDeltaX = []
    for x_i, y_i in zip(x_train,y_train):
      acumDelta.append(h(x_i,theta)-y_i)
      acumDeltaX.append((h(x_i,theta)-y_i)*x_i)

    sJt0 = sum(acumDelta)  
    sJt1 = sum(acumDeltaX)
    theta[0] = theta[0]-alpha/n*sJt0
    theta[1] = theta[1]-alpha/n*sJt1

  print(theta)

  n_train = len(y_train)
  n_test = len(y_test)

  # Validación
  acumDelta = []
  for x_i, y_i in zip(x_test,y_test):
    acumDelta.append(j_i(x_i,y_i,theta))  

  sDelta = sum(acumDelta)  
  J_test = 1/(2*n_test)*sDelta


  # Training
  acumDelta = []
  for x_i, y_i in zip(x_train,y_train):
    acumDelta.append(j_i(x_i,y_i,theta)) 

  sDelta = sum(acumDelta)
  J_train = 1/(2*n_train)*sDelta

  print("J test\n", J_test)
  print("J entrenamiento \n",J_train)
  print("theta \n",theta)